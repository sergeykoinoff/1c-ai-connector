////////////////////////////////////////////////////////////////////////////////
// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Андриянов Роман (Androman.pro)
// https://opensource.org/license/mit
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Выполняет синхронный запрос к модели ИИ
//
// Параметры:
//  Модель - СправочникСсылка.КИИ_МоделиИИ - модель для запроса
//  Промпт - Строка, Структура - запрос к модели:
//    * Строка - Строка - простой текст запроса
//    * СистемныйПромпт - Строка - системное сообщение
//    * ПользовательскийПромпт - Строка - запрос пользователя
//    * ИсторияСообщений - Массив - предыдущие ответы (необязательно)
//
// Возвращаемое значение:
//  Структура - результат запроса со свойствами:
//    * ЭтоОшибка - Булево - признак ошибки выполнения запроса
//    * ТекстОшибки - Строка - текст ошибки (если ЭтоОшибка = Истина)
//    * ТекстОтвета - Строка - текст ответа от модели ИИ
//    * ВходныеТокены - Число - количество токенов во входном запросе
//    * ВыходныеТокены - Число - количество токенов в ответе
//    * ВсегоТокенов - Число - общее количество использованных токенов
//    * ВыходныеТокеныВКеше - Число - количество закэшированных токенов
//    * ВремяОтветаСекунд - Число - время выполнения запроса в секундах
//    * СтоимостьОтвета - Число - стоимость запроса (если поддерживается провайдером)
//    * Модель - СправочникСсылка.КИИ_МоделиИИ, Неопределено - использованная модель
//    * МодельОтвета - Строка - фактическое имя модели из ответа
//    * ДатаЗапроса - Дата, Неопределено - дата и время начала запроса
//    * ДатаСоздания - Дата, Неопределено - дата создания ответа по данным провайдера
//    * ПричинаЗавершения - Строка - причина завершения генерации (stop, length и т.д.)
//    * Идентификатор - Строка - уникальный идентификатор записи лога
//    * УниверсальнаяДатаВМиллисекундах - Число - универсальное время в миллисекундах
//    * IDЗапроса - Строка - идентификатор запроса от провайдера
//    * ТипОбъекта - Строка - тип объекта ответа
//    * ТарифСервиса - Строка - использованный тариф сервиса
//    * ХэшМодели - Строка - отпечаток версии модели
//
// Пример:
//  Модель = Справочники.КИИ_МоделиИИ.НайтиПоНаименованию("GPT-4o");
//  Ответ = КИИ_КоннекторИИ.ЗапросКМодели(Модель, "Привет!");
//  
//  Если Не Ответ.ЭтоОшибка Тогда
//      Сообщить(Ответ.ТекстОтвета);
//  КонецЕсли;
//
Функция ЗапросКМодели(Модель, Промпт) Экспорт

	Результат = НовыйПараметрыОтветаИИ();
	ДатаНачала = ТекущаяДатаСеанса();

	Если Не ЗначениеЗаполнено(Модель) Тогда
		Результат.ЭтоОшибка = Истина;
		Результат.ТекстОшибки = НСтр("ru = 'Не заполнена модель ИИ'");
		Возврат Результат;
	КонецЕсли;

	Попытка

		ВыполнитьЗапросКМодели(Модель, Промпт, Результат, ДатаНачала);

	Исключение

		Результат.ЭтоОшибка = Истина;
		Результат.ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());

	КонецПопытки;

	СтруктураПромпта = ПодготовитьПромпт(Промпт);
	ЗаписатьЛогИИ(Модель, СтруктураПромпта, Результат);

	Возврат Результат;

КонецФункции

// Выполняет асинхронный запрос к модели ИИ через длительные операции
//
// Параметры:
//  Модель - СправочникСсылка.КИИ_МоделиИИ
//  Промпт - Строка, Структура - см. ЗапросКМодели
//
// Возвращаемое значение:
//  См. ДлительныеОперации.ВыполнитьВФоне
//
Функция ЗапросКМоделиВФоне(Модель, Промпт) Экспорт
	
	ПараметрыВыполнения = ДлительныеОперации.ПараметрыВыполненияВФоне(Новый УникальныйИдентификатор);
	ПараметрыВыполнения.НаименованиеФоновогоЗадания = НСтр("ru = 'Запрос к модели ИИ'");
	ПараметрыВыполнения.ЗапуститьВФоне = Истина;
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("Модель", Модель);
	ПараметрыМетода.Вставить("Промпт", Промпт);
	
	Возврат ДлительныеОперации.ВыполнитьВФоне(
		"КИИ_КоннекторИИ.ЗапросКМоделиФоновоеЗадание",
		ПараметрыМетода,
		ПараметрыВыполнения);
	
КонецФункции

// Возвращает параметры модели ИИ для выполнения HTTP-запроса
//
// Параметры:
//  Модель - СправочникСсылка.КИИ_МоделиИИ - модель ИИ
//
// Возвращаемое значение: 
//  Структура:
//    * Адрес - Строка - адрес API сервера (api.openai.com)
//    * АдресЗапроса - Строка - путь к endpoint (/v1/chat/completions)
//    * ИспользоватьЗащищенноеСоединение - Булево - использовать HTTPS
//    * ТипФорматаAPI - ПеречислениеСсылка.КИИ_ТипыФорматовAPI - формат API
//    * ТипАвторизации - ПеречислениеСсылка.КИИ_ТипыАвторизации - тип авторизации
//    * НаименованиеПровайдера - Строка - провайдер (OpenAI, GigaChat и т.д.)
//    * НаименованиеПолное - Строка - полное имя модели для API (gpt-4o)
//    * Температура - Число - температура генерации (0.0-2.0)
//    * МаксимумТокенов - Число - максимальное количество токенов ответа
//    * Таймаут - Число - таймаут HTTP запроса в секундах
//    * Заголовки - Массив из Структура - дополнительные заголовки:
//        ** Ключ - Строка - имя заголовка
//        ** Значение - Строка - значение заголовка
//
Функция ПараметрыМодели(Модель) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КИИ_МоделиИИ.Ссылка КАК Ссылка,
		|	КИИ_МоделиИИ.Наименование КАК Наименование,
		|	КИИ_МоделиИИ.НаименованиеПолное КАК НаименованиеПолное,
		|	КИИ_МоделиИИ.Адрес КАК Адрес,
		|	КИИ_МоделиИИ.АдресЗапроса КАК АдресЗапроса,
		|	КИИ_МоделиИИ.ИспользоватьЗащищенноеСоединение КАК ИспользоватьЗащищенноеСоединение,
		|	КИИ_МоделиИИ.ТипФорматаAPI КАК ТипФорматаAPI,
		|	КИИ_МоделиИИ.ТипАвторизации КАК ТипАвторизации,
		|	КИИ_МоделиИИ.НаименованиеПровайдера КАК НаименованиеПровайдера,
		|	КИИ_МоделиИИ.Температура КАК Температура,
		|	КИИ_МоделиИИ.МаксимумТокенов КАК МаксимумТокенов,
		|	КИИ_МоделиИИ.Таймаут КАК Таймаут
		|ИЗ
		|	Справочник.КИИ_МоделиИИ КАК КИИ_МоделиИИ
		|ГДЕ
		|	КИИ_МоделиИИ.Ссылка = &Модель
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	КИИ_МоделиИИЗаголовки.Ключ КАК Ключ,
		|	КИИ_МоделиИИЗаголовки.Значение КАК Значение
		|ИЗ
		|	Справочник.КИИ_МоделиИИ.Заголовки КАК КИИ_МоделиИИЗаголовки
		|ГДЕ
		|	КИИ_МоделиИИЗаголовки.Ссылка = &Модель";
	
	Запрос.УстановитьПараметр("Модель", Модель);
	
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Выборка = РезультатЗапроса[0].Выбрать();
	
	Если Не Выборка.Следующий() Тогда
		ВызватьИсключение НСтр("ru = 'Модель ИИ не найдена'");
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Адрес", Выборка.Адрес);
	Результат.Вставить("АдресЗапроса", Выборка.АдресЗапроса);
	Результат.Вставить("ИспользоватьЗащищенноеСоединение", Выборка.ИспользоватьЗащищенноеСоединение);
	Результат.Вставить("ТипФорматаAPI", Выборка.ТипФорматаAPI);
	Результат.Вставить("ТипАвторизации", Выборка.ТипАвторизации);
	Результат.Вставить("НаименованиеПровайдера", Выборка.НаименованиеПровайдера);
	Результат.Вставить("НаименованиеПолное", Выборка.НаименованиеПолное);
	Результат.Вставить("Температура", Выборка.Температура);
	Результат.Вставить("Таймаут", Выборка.Таймаут);
	Результат.Вставить("МаксимумТокенов", Выборка.МаксимумТокенов);
	Результат.Вставить("Заголовки", Новый Массив);
	
	ВыборкаЗаголовки = РезультатЗапроса[1].Выбрать();
	Пока ВыборкаЗаголовки.Следующий() Цикл
		Заголовок = Новый Структура("Ключ, Значение");
		ЗаполнитьЗначенияСвойств(Заголовок, ВыборкаЗаголовки);
		Результат.Заголовки.Добавить(Заголовок);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Процедура для выполнения запроса к модели ИИ в фоновом задании
// Используется подсистемой ДлительныеОперации
//
// Параметры:
//  ПараметрыМетода - Структура:
//    * Модель - СправочникСсылка.КИИ_МоделиИИ
//    * Промпт - Строка, Структура
//  АдресРезультата - Строка - адрес временного хранилища
//
Процедура ЗапросКМоделиФоновоеЗадание(ПараметрыМетода, АдресРезультата) Экспорт
	
	Модель = ПараметрыМетода.Модель;
	Промпт = ПараметрыМетода.Промпт;
	
	Результат = ЗапросКМодели(Модель, Промпт);
	
	ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ВыполнитьЗапросКМодели(Модель, Промпт, Результат, ДатаНачала)

	Параметры = ПараметрыМодели(Модель);
	СтруктураПромпта = ПодготовитьПромпт(Промпт);
	КлючAPI = ПолучитьКлючAPI(Модель, Параметры);

	Соединение = СоздатьHTTPСоединение(Параметры);
	Запрос = СформироватьHTTPЗапрос(Параметры, КлючAPI, СтруктураПромпта);

	Ответ = ОтправитьЗапросСПовторомПриОшибке401(Соединение, Запрос, Модель, Параметры, КлючAPI);

	Если Ответ.КодСостояния <> 200 Тогда
		ОбработатьОшибкуОтвета(Ответ, Результат);
		Возврат;
	КонецЕсли;

	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	ОтветJSON = ОбщегоНазначения.JSONВЗначение(ТелоОтвета, , Ложь);

	ОбработатьОтветПоТипуМодели(Параметры, ОтветJSON, Результат);

	Результат.ВремяОтветаСекунд = (ТекущаяДатаСеанса() - ДатаНачала);
	Результат.Модель = Модель;
	Результат.ДатаЗапроса = ДатаНачала;

КонецПроцедуры

Функция СоздатьHTTPСоединение(Параметры)

	Если Параметры.ИспользоватьЗащищенноеСоединение Тогда
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);
	Иначе
		ЗащищенноеСоединение = Неопределено;
	КонецЕсли;

	Возврат Новый HTTPСоединение(Параметры.Адрес, , , , , Параметры.Таймаут, ЗащищенноеСоединение);

КонецФункции

Функция СформироватьHTTPЗапрос(Параметры, КлючAPI, СтруктураПромпта)

	Запрос = Новый HTTPЗапрос(Параметры.АдресЗапроса);

	Заголовки = Новый Соответствие;
	ТелоЗапроса = Новый Структура;

	СформироватьЗаголовкиИТелоПоМодели(Параметры, КлючAPI, СтруктураПромпта, Заголовки, ТелоЗапроса);

	Для Каждого Заголовок Из Заголовки Цикл
		Запрос.Заголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
	КонецЦикла;

	ТелоJSON = ОбщегоНазначения.ЗначениеВJSON(ТелоЗапроса);
	Запрос.УстановитьТелоИзСтроки(ТелоJSON, КодировкаТекста.UTF8);

	Возврат Запрос;

КонецФункции

Функция ОтправитьЗапросСПовторомПриОшибке401(Соединение, Запрос, Модель, Параметры, КлючAPI)

	Ответ = Соединение.ОтправитьДляОбработки(Запрос);

	Если Ответ.КодСостояния = 401 
		И Параметры.ТипАвторизации = Перечисления.КИИ_ТипыАвторизации.OAuth2ClientCredentials Тогда

		КлючAPI = ОбновитьOAuth2Токен(Модель, Параметры);
		Запрос.Заголовки.Вставить("Authorization", "Bearer " + КлючAPI);
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);

	КонецЕсли;

	Возврат Ответ;

КонецФункции

Процедура ОбработатьОшибкуОтвета(Ответ, Результат)

	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	ТекстОшибки = РасшифровкаКодаОшибки(Ответ.КодСостояния, ТелоОтвета);

	Результат.ЭтоОшибка = Истина;
	Результат.ТекстОшибки = ТекстОшибки;

КонецПроцедуры

#Область Авторизация

Функция ПолучитьКлючAPI(Модель, Параметры) 
	
	Попытка

		КлючAPI = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(
			Модель,
			"APIКлюч");
			
		Если КлючAPI = Неопределено Тогда
			Возврат "";
		КонецЕсли;
		
		Если Параметры.ТипАвторизации = Перечисления.КИИ_ТипыАвторизации.OAuth2ClientCredentials Тогда
			Возврат ПолучитьOAuth2ТокенДоступа(КлючAPI, Параметры);
		КонецЕсли;
		
		Возврат КлючAPI;
		
	Исключение
		ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Ошибка чтения API ключа из безопасного хранилища: %1'"),
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'КИИ.APIКлюч'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ТекстОшибки);
		
		Возврат "";
		
	КонецПопытки;
	
КонецФункции

Функция ПолучитьOAuth2ТокенДоступа(УчетныеДанные, Параметры)
	
	Если Параметры.НаименованиеПровайдера = "GigaChat" Тогда
		СтруктураТокена = ПолучитьGigaChatТокенДоступа(УчетныеДанные);
		Возврат СтруктураТокена.ТокенДоступа;
	КонецЕсли;
	
	ВызватьИсключение НСтр("ru = 'Неподдерживаемый OAuth2 провайдер'");
	
КонецФункции

Функция ОбновитьOAuth2Токен(Модель, Параметры)
	
	Попытка
		УчетныеДанные = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(
			Модель,
			"APIКлюч");
			
		Если УчетныеДанные = Неопределено Тогда
			УчетныеДанные = "";
		КонецЕсли;
		
	Исключение
		УчетныеДанные = "";
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'КИИ.OAuth2'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	НовыйТокен = ПолучитьOAuth2ТокенДоступа(УчетныеДанные, Параметры);
	
	Возврат НовыйТокен;
	
КонецФункции 

Функция ПолучитьGigaChatТокенДоступа(УчетныеДанные)

	Попытка

		Base64Auth = ПодготовитьBase64АвторизациюGigaChat(УчетныеДанные);
		ОтветJSON = ВыполнитьGigaChatOAuth2Запрос(Base64Auth);

		Возврат СформироватьСтруктуруТокенаGigaChat(ОтветJSON);

	Исключение

		ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Ошибка получения GigaChat OAuth токена: %1'"),
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'КИИ.OAuth'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ТекстОшибки);

		ВызватьИсключение ТекстОшибки;

	КонецПопытки;

КонецФункции

Функция ПодготовитьBase64АвторизациюGigaChat(УчетныеДанные)

	УчетныеДанные = СокрЛП(УчетныеДанные);

	Если СтрНайти(УчетныеДанные, ":") > 0 Тогда
		Base64Auth = КодироватьУчетныеДанныеВBase64(УчетныеДанные);
	Иначе
		Base64Auth = УчетныеДанные;
	КонецЕсли;

	Возврат ОчиститьBase64ОтПробелов(Base64Auth);

КонецФункции

Функция КодироватьУчетныеДанныеВBase64(УчетныеДанные)

	Части = СтрРазделить(УчетныеДанные, ":", Ложь);

	Если Части.Количество() <> 2 Тогда
		ВызватьИсключение НСтр("ru = 'Неверный формат ClientId:ClientSecret'");
	КонецЕсли;

	СтрокаАвторизации = Части[0] + ":" + Части[1];
	ДвоичныеДанные = ПолучитьДвоичныеДанныеИзСтроки(СтрокаАвторизации, КодировкаТекста.UTF8);

	Возврат Base64Строка(ДвоичныеДанные);

КонецФункции

Функция ОчиститьBase64ОтПробелов(Base64Строка)

	Результат = Base64Строка;
	Результат = СтрЗаменить(Результат, Символы.ПС, "");
	Результат = СтрЗаменить(Результат, Символы.ВК, "");
	Результат = СтрЗаменить(Результат, Символы.ВТаб, "");
	Результат = СтрЗаменить(Результат, Символы.Таб, "");
	Результат = СтрЗаменить(Результат, " ", "");

	Возврат Результат;

КонецФункции

Функция ВыполнитьGigaChatOAuth2Запрос(Base64Auth)

	ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL(Неопределено, Неопределено);

	Соединение = Новый HTTPСоединение(
		"ngw.devices.sberbank.ru",
		9443,
		,
		,
		,
		30,
		ЗащищенноеСоединение);

	Запрос = СформироватьGigaChatOAuth2Запрос(Base64Auth);
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);

	Если Ответ.КодСостояния <> 200 Тогда
		ТекстОшибки = СтрШаблон(
			НСтр("ru = 'GigaChat OAuth ошибка %1: %2'"),
			Ответ.КодСостояния,
			Ответ.ПолучитьТелоКакСтроку());
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	Возврат ОбщегоНазначения.JSONВЗначение(ТелоОтвета);

КонецФункции

Функция СформироватьGigaChatOAuth2Запрос(Base64Auth)

	Запрос = Новый HTTPЗапрос("/api/v2/oauth");

	Запрос.Заголовки.Вставить("Authorization", "Basic " + Base64Auth);
	Запрос.Заголовки.Вставить("RqUID", XMLСтрока(Новый УникальныйИдентификатор));
	Запрос.Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Запрос.Заголовки.Вставить("Accept", "application/json");

	ТелоЗапроса = "scope=GIGACHAT_API_PERS";
	Запрос.УстановитьТелоИзСтроки(ТелоЗапроса, КодировкаТекста.UTF8);

	Возврат Запрос;

КонецФункции

Функция СформироватьСтруктуруТокенаGigaChat(ОтветJSON)

	СтруктураТокена = Новый Структура;
	СтруктураТокена.Вставить("ТокенДоступа", ОтветJSON["access_token"]);
	СтруктураТокена.Вставить("ИстекаетЧерез", 
		ОтветJSON["expires_at"] - ТекущаяУниверсальнаяДатаВМиллисекундах() / 1000);

	Возврат СтруктураТокена;

КонецФункции

#КонецОбласти

#Область ФормированиеЗапроса

Функция ПодготовитьПромпт(Промпт)
	
	СтруктураПромпта = Новый Структура;
	СтруктураПромпта.Вставить("СистемныйПромпт", "");
	СтруктураПромпта.Вставить("ПользовательскийПромпт", "");
	СтруктураПромпта.Вставить("ИсторияСообщений", Новый Массив);
	
	Если ТипЗнч(Промпт) = Тип("Строка") Тогда
		СтруктураПромпта.ПользовательскийПромпт = Промпт;
	ИначеЕсли ТипЗнч(Промпт) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(СтруктураПромпта, Промпт);
	Иначе
		ВызватьИсключение НСтр("ru = 'Неверный тип параметра Промпт. Ожидается Строка или Структура'");
	КонецЕсли;
	
	Возврат СтруктураПромпта;
	
КонецФункции

Процедура СформироватьЗаголовкиИТелоПоМодели(Параметры, КлючAPI, СтруктураПромпта, Заголовки, ТелоЗапроса)
	
	ТипФормата = Параметры.ТипФорматаAPI;
	
	Если ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.OpenAI_Compatible Тогда
		
		СформироватьЗаголовкиOpenAI(Параметры, КлючAPI, Заголовки);
		СформироватьТелоOpenAI(Параметры, СтруктураПромпта, ТелоЗапроса);
		
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.Anthropic Тогда
		
		СформироватьЗаголовкиAnthropic(Параметры, КлючAPI, Заголовки);
		СформироватьТелоAnthropic(Параметры, СтруктураПромпта, ТелоЗапроса);
		
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.Google Тогда
		
		СформироватьЗаголовкиGoogle(Параметры, КлючAPI, Заголовки);
		СформироватьТелоGoogle(Параметры, СтруктураПромпта, ТелоЗапроса);
		
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.Yandex Тогда
		
		СформироватьЗаголовкиYandex(Параметры, КлючAPI, Заголовки);
		СформироватьТелоYandex(Параметры, СтруктураПромпта, ТелоЗапроса);
		
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.GigaChat Тогда
		
		СформироватьЗаголовкиGigaChat(Параметры, КлючAPI, Заголовки);
		СформироватьТелоGigaChat(Параметры, СтруктураПромпта, ТелоЗапроса);
		
	Иначе
		ВызватьИсключение НСтр("ru = 'Неподдерживаемый формат API'");
	КонецЕсли;
	
	Для Каждого Заголовок Из Параметры.Заголовки Цикл
		Заголовки.Вставить(Заголовок.Ключ, Заголовок.Значение);
	КонецЦикла;
	
КонецПроцедуры

#Область OpenAI

Процедура СформироватьЗаголовкиOpenAI(Параметры, КлючAPI, Заголовки)
	
	Заголовки.Вставить("Content-Type", "application/json");
	
	Если ЗначениеЗаполнено(КлючAPI) Тогда
		Заголовки.Вставить("Authorization", "Bearer " + КлючAPI);
	КонецЕсли;
	
КонецПроцедуры

Процедура СформироватьТелоOpenAI(Параметры, СтруктураПромпта, ТелоЗапроса)

	МассивСообщений = СформироватьМассивСообщенийOpenAIФормат(СтруктураПромпта);

	ТелоЗапроса.Вставить("model", Параметры.НаименованиеПолное);
	ТелоЗапроса.Вставить("messages", МассивСообщений);

	ДобавитьПараметрыГенерацииOpenAI(Параметры, ТелоЗапроса);

КонецПроцедуры

Функция СформироватьМассивСообщенийOpenAIФормат(СтруктураПромпта)

	МассивСообщений = Новый Массив;

	Если ЗначениеЗаполнено(СтруктураПромпта.СистемныйПромпт) Тогда
		СообщениеСистема = Новый Структура("role, content", "system", СтруктураПромпта.СистемныйПромпт);
		МассивСообщений.Добавить(СообщениеСистема);
	КонецЕсли;

	Если СтруктураПромпта.Свойство("ИсторияСообщений") Тогда
		ДобавитьИсториюСообщенийOpenAI(МассивСообщений, СтруктураПромпта.ИсторияСообщений);
	КонецЕсли;

	СообщениеПользователь = Новый Структура("role, content", "user", СтруктураПромпта.ПользовательскийПромпт);
	МассивСообщений.Добавить(СообщениеПользователь);

	Возврат МассивСообщений;

КонецФункции

Процедура ДобавитьИсториюСообщенийOpenAI(МассивСообщений, ИсторияСообщений)

	Для Каждого Сообщение Из ИсторияСообщений Цикл
		СообщениеИстории = Новый Структура("role, content", Сообщение.Роль, Сообщение.Текст);
		МассивСообщений.Добавить(СообщениеИстории);
	КонецЦикла;

КонецПроцедуры

Процедура ДобавитьПараметрыГенерацииOpenAI(Параметры, ТелоЗапроса)

	Если ЗначениеЗаполнено(Параметры.Температура) Тогда
		ТелоЗапроса.Вставить("temperature", Параметры.Температура);
	КонецЕсли;

	Если ЗначениеЗаполнено(Параметры.МаксимумТокенов) Тогда
		ТелоЗапроса.Вставить("max_tokens", Параметры.МаксимумТокенов);
	КонецЕсли;

	Если Параметры.НаименованиеПровайдера = "Ollama" Тогда
		ТелоЗапроса.Вставить("stream", Ложь);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область Anthropic

Процедура СформироватьЗаголовкиAnthropic(Параметры, КлючAPI, Заголовки)
	
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("x-api-key", КлючAPI);
	Заголовки.Вставить("anthropic-version", "2023-06-01");
	
КонецПроцедуры

Процедура СформироватьТелоAnthropic(Параметры, СтруктураПромпта, ТелоЗапроса)
	
	МассивСообщений = Новый Массив;
	
	Если СтруктураПромпта.Свойство("ИсторияСообщений") Тогда
		Для Каждого Сообщение Из СтруктураПромпта.ИсторияСообщений Цикл
			СообщениеИстории = Новый Структура("role, content", Сообщение.Роль, Сообщение.Текст);
			МассивСообщений.Добавить(СообщениеИстории);
		КонецЦикла;
	КонецЕсли;
	
	СообщениеПользователь = Новый Структура("role, content", "user", СтруктураПромпта.ПользовательскийПромпт);
	МассивСообщений.Добавить(СообщениеПользователь);
	
	ТелоЗапроса.Вставить("model", Параметры.НаименованиеПолное);
	ТелоЗапроса.Вставить("messages", МассивСообщений);
	ТелоЗапроса.Вставить("max_tokens", ?(Параметры.МаксимумТокенов > 0, Параметры.МаксимумТокенов, 4096));
	
	Если ЗначениеЗаполнено(СтруктураПромпта.СистемныйПромпт) Тогда
		ТелоЗапроса.Вставить("system", СтруктураПромпта.СистемныйПромпт);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Параметры.Температура) Тогда
		ТелоЗапроса.Вставить("temperature", Параметры.Температура);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Google

Процедура СформироватьЗаголовкиGoogle(Параметры, КлючAPI, Заголовки)
	
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("x-goog-api-key", КлючAPI);
	
КонецПроцедуры

Процедура СформироватьТелоGoogle(Параметры, СтруктураПромпта, ТелоЗапроса)

	Содержания = СформироватьСодержанияGoogle(СтруктураПромпта);
	КонфигурацияГенерации = СформироватьКонфигурациюГенерацииGoogle(Параметры);

	ТелоЗапроса.Вставить("contents", Содержания);
	ТелоЗапроса.Вставить("generationConfig", КонфигурацияГенерации);

	Если ЗначениеЗаполнено(СтруктураПромпта.СистемныйПромпт) Тогда
		ДобавитьСистемнуюИнструкциюGoogle(ТелоЗапроса, СтруктураПромпта.СистемныйПромпт);
	КонецЕсли;

КонецПроцедуры

Функция СформироватьСодержанияGoogle(СтруктураПромпта)

	Содержания = Новый Массив;

	Если СтруктураПромпта.Свойство("ИсторияСообщений") Тогда
		ДобавитьИсториюСообщенийGoogle(Содержания, СтруктураПромпта.ИсторияСообщений);
	КонецЕсли;

	ДобавитьСообщениеGoogle(Содержания, "user", СтруктураПромпта.ПользовательскийПромпт);

	Возврат Содержания;

КонецФункции

Процедура ДобавитьИсториюСообщенийGoogle(Содержания, ИсторияСообщений)

	Для Каждого Сообщение Из ИсторияСообщений Цикл
		РольGoogle = ?(Сообщение.Роль = "assistant", "model", Сообщение.Роль);
		ДобавитьСообщениеGoogle(Содержания, РольGoogle, Сообщение.Текст);
	КонецЦикла;

КонецПроцедуры

Процедура ДобавитьСообщениеGoogle(Содержания, Роль, Текст)

	Части = Новый Массив;
	Часть = Новый Структура("text", Текст);
	Части.Добавить(Часть);

	Содержимое = Новый Структура;
	Содержимое.Вставить("role", Роль);
	Содержимое.Вставить("parts", Части);

	Содержания.Добавить(Содержимое);

КонецПроцедуры

Функция СформироватьКонфигурациюГенерацииGoogle(Параметры)

	КонфигурацияГенерации = Новый Структура;
	КонфигурацияГенерации.Вставить("temperature", Параметры.Температура);

	Если ЗначениеЗаполнено(Параметры.МаксимумТокенов) Тогда
		КонфигурацияГенерации.Вставить("maxOutputTokens", Параметры.МаксимумТокенов);
	КонецЕсли;

	Возврат КонфигурацияГенерации;

КонецФункции

Процедура ДобавитьСистемнуюИнструкциюGoogle(ТелоЗапроса, СистемныйПромпт)

	СистемнаяИнструкция = Новый Структура;
	СистемнаяИнструкция.Вставить("parts", Новый Массив);

	ЧастьСистемы = Новый Структура("text", СистемныйПромпт);
	СистемнаяИнструкция.parts.Добавить(ЧастьСистемы);

	ТелоЗапроса.Вставить("systemInstruction", СистемнаяИнструкция);

КонецПроцедуры

#КонецОбласти

#Область Yandex

Процедура СформироватьЗаголовкиYandex(Параметры, КлючAPI, Заголовки)
	
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("Authorization", "Api-Key " + КлючAPI);
	
КонецПроцедуры

Процедура СформироватьТелоYandex(Параметры, СтруктураПромпта, ТелоЗапроса)

	МассивСообщений = СформироватьМассивСообщенийYandexФормат(СтруктураПромпта);
	ПараметрыВызова = СформироватьПараметрыВызоваYandex(Параметры);

	ТелоЗапроса.Вставить("modelUri", Параметры.НаименованиеПолное);
	ТелоЗапроса.Вставить("completionOptions", ПараметрыВызова);
	ТелоЗапроса.Вставить("messages", МассивСообщений);

КонецПроцедуры

Функция СформироватьМассивСообщенийYandexФормат(СтруктураПромпта)

	МассивСообщений = Новый Массив;

	Если ЗначениеЗаполнено(СтруктураПромпта.СистемныйПромпт) Тогда
		СообщениеСистема = Новый Структура("role, text", "system", СтруктураПромпта.СистемныйПромпт);
		МассивСообщений.Добавить(СообщениеСистема);
	КонецЕсли;

	Если СтруктураПромпта.Свойство("ИсторияСообщений") Тогда
		ДобавитьИсториюСообщенийYandex(МассивСообщений, СтруктураПромпта.ИсторияСообщений);
	КонецЕсли;

	СообщениеПользователь = Новый Структура("role, text", "user", СтруктураПромпта.ПользовательскийПромпт);
	МассивСообщений.Добавить(СообщениеПользователь);

	Возврат МассивСообщений;

КонецФункции

Процедура ДобавитьИсториюСообщенийYandex(МассивСообщений, ИсторияСообщений)

	Для Каждого Сообщение Из ИсторияСообщений Цикл
		СообщениеИстории = Новый Структура("role, text", Сообщение.Роль, Сообщение.Текст);
		МассивСообщений.Добавить(СообщениеИстории);
	КонецЦикла;

КонецПроцедуры

Функция СформироватьПараметрыВызоваYandex(Параметры)

	ПараметрыВызова = Новый Структура;
	ПараметрыВызова.Вставить("stream", Ложь);
	ПараметрыВызова.Вставить("temperature", Параметры.Температура);

	Если ЗначениеЗаполнено(Параметры.МаксимумТокенов) Тогда
		ПараметрыВызова.Вставить("maxTokens", Параметры.МаксимумТокенов);
	КонецЕсли;

	Возврат ПараметрыВызова;

КонецФункции

#КонецОбласти

#Область GigaChat

Процедура СформироватьЗаголовкиGigaChat(Параметры, КлючAPI, Заголовки)
	
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("Authorization", "Bearer " + КлючAPI);
	
КонецПроцедуры

Процедура СформироватьТелоGigaChat(Параметры, СтруктураПромпта, ТелоЗапроса)

	// GigaChat использует OpenAI-совместимый формат
	СформироватьТелоOpenAI(Параметры, СтруктураПромпта, ТелоЗапроса);

КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область ОбработкаОтвета

Процедура ОбработатьОтветПоТипуМодели(Параметры, ОтветJSON, Результат)

	Если ЕстьОшибкаВОтветеAPI(ОтветJSON, Результат) Тогда
		Возврат;
	КонецЕсли;

	ТипФормата = Параметры.ТипФорматаAPI;

	Если ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.OpenAI_Compatible Тогда
		ОбработатьОтветOpenAI(ОтветJSON, Результат);
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.Anthropic Тогда
		ОбработатьОтветAnthropic(ОтветJSON, Результат);
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.Google Тогда
		ОбработатьОтветGoogle(ОтветJSON, Результат);
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.Yandex Тогда
		ОбработатьОтветYandex(ОтветJSON, Результат);
	ИначеЕсли ТипФормата = Перечисления.КИИ_ТипыФорматовAPI.GigaChat Тогда
		ОбработатьОтветGigaChat(ОтветJSON, Результат);
	Иначе
		ВызватьИсключение НСтр("ru = 'Неподдерживаемый формат API'");
	КонецЕсли;

КонецПроцедуры

#Область ОбработкаОтветаOpenAI

Процедура ОбработатьОтветOpenAI(ОтветJSON, Результат)

	ИзвлечьТекстОтветаOpenAI(ОтветJSON, Результат);
	ИзвлечьМетаданныеOpenAI(ОтветJSON, Результат);
	ИзвлечьТокеныOpenAI(ОтветJSON, Результат);

КонецПроцедуры

Функция ЕстьОшибкаВОтветеAPI(ОтветJSON, Результат)

	Если ТипЗнч(ОтветJSON) <> Тип("Структура") Тогда
		Возврат Ложь;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("error") Тогда
		Возврат Ложь;
	КонецЕсли;

	Результат.ЭтоОшибка = Истина;

	Если ТипЗнч(ОтветJSON.error) = Тип("Структура") 
		И ОтветJSON.error.Свойство("message") Тогда
		Результат.ТекстОшибки = ОтветJSON.error.message;
	Иначе
		Результат.ТекстОшибки = Строка(ОтветJSON.error);
	КонецЕсли;

	Возврат Истина;

КонецФункции

Процедура ИзвлечьТекстОтветаOpenAI(ОтветJSON, Результат)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("choices") 
		Или Не ЭтоМассив(ОтветJSON.choices)
		Или ОтветJSON.choices.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	Выборка = ОтветJSON.choices[0];

	Если Не ЭтоСтруктура(Выборка) Тогда
		Возврат;
	КонецЕсли;

	Если Не Выборка.Свойство("message") 
		Или Не ЭтоСтруктура(Выборка.message) Тогда
		Возврат;
	КонецЕсли;

	Если Выборка.message.Свойство("content") Тогда
		Результат.ТекстОтвета = Выборка.message.content;
	КонецЕсли;

	Если Выборка.Свойство("finish_reason") Тогда
		Результат.ПричинаЗавершения = Выборка.finish_reason;
	КонецЕсли;

КонецПроцедуры

Процедура ИзвлечьМетаданныеOpenAI(ОтветJSON, Результат)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат;
	КонецЕсли;

	Если ОтветJSON.Свойство("id") Тогда
		Результат.IDЗапроса = ОтветJSON.id;
	КонецЕсли;

	Если ОтветJSON.Свойство("created") Тогда
		Результат.ДатаСоздания = Дата(1970, 1, 1) + ОтветJSON.created;
	КонецЕсли;

	Если ОтветJSON.Свойство("model") Тогда
		Результат.МодельОтвета = ОтветJSON.model;
	КонецЕсли;

	Если ОтветJSON.Свойство("object") Тогда
		Результат.ТипОбъекта = ОтветJSON.object;
	КонецЕсли;

	Если ОтветJSON.Свойство("service_tier") Тогда
		Результат.ТарифСервиса = ОтветJSON.service_tier;
	КонецЕсли;

	Если ОтветJSON.Свойство("system_fingerprint") Тогда
		Результат.ХэшМодели = ОтветJSON.system_fingerprint;
	КонецЕсли;

КонецПроцедуры

Процедура ИзвлечьТокеныOpenAI(ОтветJSON, Результат)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("usage") 
		Или Не ЭтоСтруктура(ОтветJSON.usage) Тогда
		Возврат;
	КонецЕсли;

	Использование = ОтветJSON.usage;

	Если Использование.Свойство("prompt_tokens") Тогда
		Результат.ВходныеТокены = Использование.prompt_tokens;
	КонецЕсли;

	Если Использование.Свойство("completion_tokens") Тогда
		Результат.ВыходныеТокены = Использование.completion_tokens;
	КонецЕсли;

	Если Использование.Свойство("total_tokens") Тогда
		Результат.ВсегоТокенов = Использование.total_tokens;
	КонецЕсли;

	ИзвлечьКешированныеТокеныOpenAI(Использование, Результат);

КонецПроцедуры

Процедура ИзвлечьКешированныеТокеныOpenAI(Использование, Результат)

	Если Не Использование.Свойство("completion_tokens_details") Тогда
		Возврат;
	КонецЕсли;

	Если Не ЭтоСтруктура(Использование.completion_tokens_details) Тогда
		Возврат;
	КонецЕсли;

	Если Использование.completion_tokens_details.Свойство("cached_tokens") Тогда
		Результат.ВыходныеТокеныВКеше = Использование.completion_tokens_details.cached_tokens;
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область ОбработкаОтветаAnthropic

Процедура ОбработатьОтветAnthropic(ОтветJSON, Результат)

	ИзвлечьТекстОтветаAnthropic(ОтветJSON, Результат);
	ИзвлечьМетаданныеAnthropic(ОтветJSON, Результат);
	ИзвлечьТокеныAnthropic(ОтветJSON, Результат);

КонецПроцедуры

Процедура ИзвлечьТекстОтветаAnthropic(ОтветJSON, Результат)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("content") 
		Или Не ЭтоМассив(ОтветJSON.content)
		Или ОтветJSON.content.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	ПервыйЭлемент = ОтветJSON.content[0];

	Если ЭтоСтруктура(ПервыйЭлемент) 
		И ПервыйЭлемент.Свойство("text") Тогда
		Результат.ТекстОтвета = ПервыйЭлемент.text;
	КонецЕсли;

КонецПроцедуры

Процедура ИзвлечьМетаданныеAnthropic(ОтветJSON, Результат)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат;
	КонецЕсли;

	Если ОтветJSON.Свойство("id") Тогда
		Результат.IDЗапроса = ОтветJSON.id;
	КонецЕсли;

	Если ОтветJSON.Свойство("model") Тогда
		Результат.МодельОтвета = ОтветJSON.model;
	КонецЕсли;

	Если ОтветJSON.Свойство("stop_reason") Тогда
		Результат.ПричинаЗавершения = ОтветJSON.stop_reason;
	КонецЕсли;

КонецПроцедуры

Процедура ИзвлечьТокеныAnthropic(ОтветJSON, Результат)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("usage") 
		Или Не ЭтоСтруктура(ОтветJSON.usage) Тогда
		Возврат;
	КонецЕсли;

	Использование = ОтветJSON.usage;

	Если Использование.Свойство("input_tokens") Тогда
		Результат.ВходныеТокены = Использование.input_tokens;
	КонецЕсли;

	Если Использование.Свойство("output_tokens") Тогда
		Результат.ВыходныеТокены = Использование.output_tokens;
	КонецЕсли;

	Результат.ВсегоТокенов = Результат.ВходныеТокены + Результат.ВыходныеТокены;

КонецПроцедуры

#КонецОбласти

#Область ОбработкаОтветаGoogle

Процедура ОбработатьОтветGoogle(ОтветJSON, Результат)

	ИзвлечьТекстОтветаGoogle(ОтветJSON, Результат);
	ИзвлечьТокеныGoogle(ОтветJSON, Результат);

КонецПроцедуры

Процедура ИзвлечьТекстОтветаGoogle(ОтветJSON, Результат)

	Кандидат = ПолучитьПервогоКандидатаGoogle(ОтветJSON);

	Если Кандидат = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ИзвлечьТекстИзКандидатаGoogle(Кандидат, Результат);

	Если Кандидат.Свойство("finishReason") Тогда
		Результат.ПричинаЗавершения = Кандидат.finishReason;
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьПервогоКандидатаGoogle(ОтветJSON)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("candidates") 
		Или Не ЭтоМассив(ОтветJSON.candidates)
		Или ОтветJSON.candidates.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	Кандидат = ОтветJSON.candidates[0];

	Если Не ЭтоСтруктура(Кандидат) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Возврат Кандидат;

КонецФункции

Процедура ИзвлечьТекстИзКандидатаGoogle(Кандидат, Результат)

	Если Не Кандидат.Свойство("content") 
		Или Не ЭтоСтруктура(Кандидат.content) Тогда
		Возврат;
	КонецЕсли;

	Если Не Кандидат.content.Свойство("parts") 
		Или Не ЭтоМассив(Кандидат.content.parts)
		Или Кандидат.content.parts.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	ПерваяЧасть = Кандидат.content.parts[0];

	Если ЭтоСтруктура(ПерваяЧасть) 
		И ПерваяЧасть.Свойство("text") Тогда
		Результат.ТекстОтвета = ПерваяЧасть.text;
	КонецЕсли;

КонецПроцедуры

Процедура ИзвлечьТокеныGoogle(ОтветJSON, Результат)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("usageMetadata") 
		Или Не ЭтоСтруктура(ОтветJSON.usageMetadata) Тогда
		Возврат;
	КонецЕсли;

	Использование = ОтветJSON.usageMetadata;

	Если Использование.Свойство("promptTokenCount") Тогда
		Результат.ВходныеТокены = Использование.promptTokenCount;
	КонецЕсли;

	Если Использование.Свойство("candidatesTokenCount") Тогда
		Результат.ВыходныеТокены = Использование.candidatesTokenCount;
	КонецЕсли;

	Если Использование.Свойство("totalTokenCount") Тогда
		Результат.ВсегоТокенов = Использование.totalTokenCount;
	КонецЕсли;

КонецПроцедуры


#КонецОбласти

#Область ОбработкаОтветаYandex

Процедура ОбработатьОтветYandex(ОтветJSON, Результат)

	ИзвлечьТекстОтветаYandex(ОтветJSON, Результат);
	ИзвлечьМетаданныеYandex(ОтветJSON, Результат);
	ИзвлечьТокеныYandex(ОтветJSON, Результат);

КонецПроцедуры

Процедура ИзвлечьТекстОтветаYandex(ОтветJSON, Результат)

	РезультатYandex = ПолучитьРезультатYandex(ОтветJSON);

	Если РезультатYandex = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ИзвлечьТекстИзАльтернативYandex(РезультатYandex, Результат);

КонецПроцедуры

Функция ПолучитьРезультатYandex(ОтветJSON)

	Если Не ЭтоСтруктура(ОтветJSON) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Не ОтветJSON.Свойство("result") 
		Или Не ЭтоСтруктура(ОтветJSON.result) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Возврат ОтветJSON.result;

КонецФункции

Процедура ИзвлечьТекстИзАльтернативYandex(РезультатYandex, Результат)

	Если Не РезультатYandex.Свойство("alternatives") 
		Или Не ЭтоМассив(РезультатYandex.alternatives)
		Или РезультатYandex.alternatives.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	Вариант = РезультатYandex.alternatives[0];

	Если Не ЭтоСтруктура(Вариант) Тогда
		Возврат;
	КонецЕсли;

	Если Вариант.Свойство("message") 
		И ЭтоСтруктура(Вариант.message)
		И Вариант.message.Свойство("text") Тогда
		Результат.ТекстОтвета = Вариант.message.text;
	КонецЕсли;

	Если Вариант.Свойство("status") Тогда
		Результат.ПричинаЗавершения = Вариант.status;
	КонецЕсли;

КонецПроцедуры

Процедура ИзвлечьМетаданныеYandex(ОтветJSON, Результат)

	РезультатYandex = ПолучитьРезультатYandex(ОтветJSON);

	Если РезультатYandex = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если РезультатYandex.Свойство("modelVersion") Тогда
		Результат.МодельОтвета = РезультатYandex.modelVersion;
	КонецЕсли;

КонецПроцедуры

Процедура ИзвлечьТокеныYandex(ОтветJSON, Результат)

	РезультатYandex = ПолучитьРезультатYandex(ОтветJSON);

	Если РезультатYandex = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если Не РезультатYandex.Свойство("usage") 
		Или Не ЭтоСтруктура(РезультатYandex.usage) Тогда
		Возврат;
	КонецЕсли;

	Использование = РезультатYandex.usage;

	Если Использование.Свойство("inputTextTokens") Тогда
		Результат.ВходныеТокены = Использование.inputTextTokens;
	КонецЕсли;

	Если Использование.Свойство("completionTokens") Тогда
		Результат.ВыходныеТокены = Использование.completionTokens;
	КонецЕсли;

	Если Использование.Свойство("totalTokens") Тогда
		Результат.ВсегоТокенов = Использование.totalTokens;
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область ОбработкаОтветаGigaChat
 
Процедура ОбработатьОтветGigaChat(ОтветJSON, Результат)

	// GigaChat использует OpenAI-совместимый формат
	ОбработатьОтветOpenAI(ОтветJSON, Результат);

КонецПроцедуры

#КонецОбласти
#КонецОбласти

#Область Логирование

Процедура ЗаписатьЛогИИ(Модель, СтруктураПромпта, Результат)
	
	МенеджерЗаписи = РегистрыСведений.КИИ_ЛогЗапросовИИ.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Заполнить(Неопределено); 
	ЗаполнитьЗначенияСвойств(МенеджерЗаписи, Результат);
	ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СтруктураПромпта);
	
	Если СтруктураПромпта.Свойство("ИсторияСообщений") 
		И СтруктураПромпта.ИсторияСообщений.Количество() > 0 Тогда
		
		Попытка
			МенеджерЗаписи.ИсторияСообщенийJSON = ОбщегоНазначения.ЗначениеВJSON(СтруктураПромпта.ИсторияСообщений);
		Исключение
			ТекстОшибки = СтрШаблон(
				НСтр("ru = 'Ошибка сериализации истории сообщений: %1'"),
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'КИИ.Логирование'", ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				ТекстОшибки);
		КонецПопытки;
		
	КонецЕсли;
	
	МенеджерЗаписи.Записать();
	
КонецПроцедуры

#КонецОбласти

#Область ВспомогательныеФункции

// Создает новую структуру параметров ответа от модели ИИ
//
// Возвращаемое значение:
//  Структура - параметры ответа с полями:
//    * ЭтоОшибка - Булево - признак ошибки выполнения запроса
//    * ТекстОшибки - Строка - текст ошибки (пустая строка при успехе)
//    * ТекстОтвета - Строка - текст ответа от модели ИИ
//    * ВходныеТокены - Число - количество токенов во входном запросе
//    * ВыходныеТокены - Число - количество токенов в ответе
//    * ВсегоТокенов - Число - общее количество использованных токенов
//    * ВыходныеТокеныВКеше - Число - количество закэшированных токенов
//    * ВремяОтветаСекунд - Число - время выполнения запроса в секундах
//    * СтоимостьОтвета - Число - стоимость запроса (если поддерживается провайдером)
//    * Модель - СправочникСсылка.КИИ_МоделиИИ, Неопределено - использованная модель
//    * МодельОтвета - Строка - фактическое имя модели из ответа провайдера
//    * ДатаЗапроса - Дата, Неопределено - дата и время начала запроса
//    * ДатаСоздания - Дата, Неопределено - дата создания ответа по данным провайдера
//    * ПричинаЗавершения - Строка - причина завершения генерации (stop, length и т.д.)
//    * Идентификатор - Строка - уникальный идентификатор записи лога
//    * УниверсальнаяДатаВМиллисекундах - Число - универсальное время в миллисекундах
//    * IDЗапроса - Строка - идентификатор запроса от провайдера
//    * ТипОбъекта - Строка - тип объекта ответа
//    * ТарифСервиса - Строка - использованный тариф сервиса
//    * ХэшМодели - Строка - отпечаток версии модели (system_fingerprint)
//
Функция НовыйПараметрыОтветаИИ()
	
	Результат = Новый Структура;
	
	Результат.Вставить("ЭтоОшибка", Ложь);
	Результат.Вставить("ТекстОшибки", "");
	Результат.Вставить("ТекстОтвета", "");
	
	Результат.Вставить("ВходныеТокены", 0);
	Результат.Вставить("ВыходныеТокены", 0);
	Результат.Вставить("ВсегоТокенов", 0);
	Результат.Вставить("ВыходныеТокеныВКеше", 0);
	Результат.Вставить("ВремяОтветаСекунд", 0);
	Результат.Вставить("СтоимостьОтвета", 0);
	
	Результат.Вставить("Модель", Неопределено);
	Результат.Вставить("МодельОтвета", "");
	Результат.Вставить("Идентификатор", Новый УникальныйИдентификатор());
	Результат.Вставить("IDЗапроса", "");
	
	Результат.Вставить("ДатаЗапроса", Неопределено);
	Результат.Вставить("ДатаСоздания", Неопределено);
	Результат.Вставить("УниверсальнаяДатаВМиллисекундах", ТекущаяУниверсальнаяДатаВМиллисекундах());
	
	Результат.Вставить("ПричинаЗавершения", "");
	Результат.Вставить("ТипОбъекта", "");
	Результат.Вставить("ТарифСервиса", "");
	Результат.Вставить("ХэшМодели", "");
	
	Возврат Результат;
	
КонецФункции

Функция ЭтоСтруктура(Знач Значение)

	Возврат ТипЗнч(Значение) = Тип("Структура");

КонецФункции

Функция ЭтоМассив(Знач Значение)

	Возврат ТипЗнч(Значение) = Тип("Массив");

КонецФункции

#КонецОбласти

Функция РасшифровкаКодаОшибки(КодHTTP, СтрОшибкаJSON = "")

	КодAPI = ИзвлечьКодОшибкиAPI(СтрОшибкаJSON);
	ТекстОшибки = ПолучитьОписаниеHTTPОшибки(КодHTTP);

	Если Не ПустаяСтрока(КодAPI) Тогда
		ОписаниеAPIОшибки = ПолучитьОписаниеAPIОшибки(КодAPI);

		Если ОписаниеAPIОшибки <> Неопределено Тогда
			ТекстОшибки = СтрШаблон("%1, %2", ТекстОшибки, ОписаниеAPIОшибки);
		КонецЕсли;
	КонецЕсли;

	Возврат ТекстОшибки;

КонецФункции

Функция ИзвлечьКодОшибкиAPI(СтрОшибкаJSON)

	Если ПустаяСтрока(СтрОшибкаJSON) Тогда
		Возврат "";
	КонецЕсли;

	Попытка
		СтруктураОшибки = ОбщегоНазначения.JSONВЗначение(СтрОшибкаJSON);

		Если ТипЗнч(СтруктураОшибки) = Тип("Структура") 
			И СтруктураОшибки.Свойство("code") Тогда
			Возврат СтруктураОшибки.code;
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'КИИ.HTTPОшибка'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;

	Возврат "";

КонецФункции

Функция ПолучитьОписаниеHTTPОшибки(КодHTTP)

	КартаHTTP = Новый Соответствие;
	КартаHTTP.Вставить(400, НСтр("ru = 'Неверный запрос (400)'"));
	КартаHTTP.Вставить(401, НСтр("ru = 'Ключ API отсутствует или недействителен (401)'"));
	КартаHTTP.Вставить(403, НСтр("ru = 'Доступ запрещен (403)'"));
	КартаHTTP.Вставить(404, НСтр("ru = 'Ресурс не найден (404)'"));
	КартаHTTP.Вставить(429, НСтр("ru = 'Превышен лимит запросов или квота (429)'"));
	КартаHTTP.Вставить(500, НСтр("ru = 'Внутренняя ошибка сервера (500)'"));
	КартаHTTP.Вставить(502, НСтр("ru = 'Bad Gateway (502)'"));
	КартаHTTP.Вставить(503, НСтр("ru = 'Сервис временно недоступен (503)'"));
	КартаHTTP.Вставить(504, НСтр("ru = 'Gateway Timeout (504)'"));

	ОписаниеКодаОшибки = КартаHTTP.Получить(КодHTTP);

	Если ОписаниеКодаОшибки = Неопределено Тогда
		Возврат СтрШаблон(НСтр("ru = 'Неизвестная ошибка: %1'"), КодHTTP);
	КонецЕсли;

	Возврат ОписаниеКодаОшибки;

КонецФункции

Функция ПолучитьОписаниеAPIОшибки(КодAPI)

	КартаAPI = Новый Соответствие;
	КартаAPI.Вставить("invalid_api_key",         НСтр("ru = 'Ключ API недействителен или отозван'"));
	КартаAPI.Вставить("insufficient_quota",      НСтр("ru = 'Недостаточная квота для операции'"));
	КартаAPI.Вставить("context_length_exceeded", НСтр("ru = 'Превышена максимальная длина контекста'"));
	КартаAPI.Вставить("rate_limit_reached",      НСтр("ru = 'Достигнут предел скорости запросов'"));
	КартаAPI.Вставить("model_not_found",         НСтр("ru = 'Запрошенная модель не найдена'"));
	КартаAPI.Вставить("server_overloaded",       НСтр("ru = 'Сервер перегружен, попробуйте позже'"));
	КартаAPI.Вставить("timeout",                 НСтр("ru = 'Превышено время ожидания операции'"));

	Возврат КартаAPI.Получить(КодAPI);

КонецФункции

#КонецОбласти
